<script lang="ts">
  import { onMount, onDestroy, getContext, setContext } from 'svelte';
  import { findRoute, createRouter, addRoute } from 'rou3';

  type RouterStatus = 'ready' | 'loading' | 'not-found' | 'error';

  interface RouterProps {
    fallback?: any;
    base?: string;
    loading?: any;
    error?: any;
  }

  let { fallback = null, base = '', loading, error }: RouterProps = $props();

  const isBrowser = typeof window !== 'undefined';
  let routes: any[] = $state([]);

  async function loadRoutes() {
    try {
      const routesModule = await import('virtual:oxide-routes');
      routes = routesModule.routes || [];
    } catch (error) {
      console.warn('Virtual routes not available, router may not work properly');
      routes = [];
      routerError = new Error('Routes not generated by plugin');
      routerState = 'error';
    }
  }

  let routerState = $state<RouterStatus>('ready');
  let currentLocation = $state({
    pathname: '/',
    search: '',
    hash: ''
  });
  let currentRoute = $state<any>(null);
  let currentParams = $state<Record<string, string>>({});
  let currentComponent = $state<any>(null);
  let routerError = $state<Error | null>(null);
  let isNavigating = $state(false);

  function navigate(path: string, options: any = {}) {
    if (!isBrowser) return;

    const action = options.replace ? 'replaceState' : 'pushState';
    history[action]({}, '', base + path);
    isNavigating = true;
    updateLocation();
  }

  function generatePath(name: string, params: Record<string, any> = {}) {
    const route = findRouteByName(name);
    if (!route) {
      throw new Error(`Route "${name}" not found`);
    }

    let path = route.path;
    for (const [key, value] of Object.entries(params)) {
      if (Array.isArray(value)) {
        path = path.replace('*', value.join('/'));
        continue;
      }
      const paramRegex = new RegExp(`:${key}\\??`, 'g');
      path = path.replace(paramRegex, String(value));
    }
    path = path.replace(/\/:[^/]+\?/g, '');
    return path || '/';
  }

  const routerContext = {
    navigate,
    location: () => currentLocation,
    route: () => currentRoute,
    params: () => currentParams,
    generatePath
  };
  setContext('router', routerContext);

  function buildRouter(routes: any[]) {
    const router = createRouter();

    function addRoutesToRouter(routeList: any[], parentPath = '') {
      for (const route of routeList) {
        const fullPath = parentPath === '' && route.path === '/'
          ? '/'
          : (parentPath + route.path).replace(/\/+/g, '/');

        addRoute(router, "GET", fullPath, {
          name: route.name,
          component: route.component,
          meta: route.meta || {},
          params: route.params || []
        });

        if (route.alias) {
          for (const alias of route.alias) {
            const aliasPath = parentPath === '' && alias === '/'
              ? '/'
              : (parentPath + alias).replace(/\/+/g, '/');

            addRoute(router, "GET", aliasPath, {
              name: route.name,
              component: route.component,
              meta: route.meta || {},
              params: route.params || [],
              isAlias: true
            });
          }
        }

        if (route.children && route.children.length > 0) {
          addRoutesToRouter(route.children, fullPath);
        }
      }
    }

    addRoutesToRouter(routes);
    return router;
  }

  let router = $state(createRouter());

  function findRouteByName(name: string): any {
    function searchRoutes(routeList: any[]): any {
      for (const route of routeList) {
        if (route.name === name) return route;
        if (route.children) {
          const found = searchRoutes(route.children);
          if (found) return found;
        }
      }
      return null;
    }
    return searchRoutes(routes);
  }

  async function updateLocation(): Promise<void> {
    if (!isBrowser) return;

    if (isNavigating) {
      routerState = 'loading';
    }

    const url = new URL(window.location.href);
    let pathname = url.pathname;

    if (base && pathname.startsWith(base)) {
      pathname = pathname.slice(base.length) || '/';
    }

    currentLocation = {
      pathname,
      search: url.search,
      hash: url.hash
    };

    const match = findRoute(router, "GET", pathname);

    if (match && match.data) {
      try {
        currentRoute = match.data;
        currentParams = extractParams(pathname, match.data);

        await loadComponent(match.data.component);
        routerState = 'ready';
        isNavigating = false;
        return;
      } catch (error) {
        console.error('Failed to load route:', error);
        routerError = error as Error;
        routerState = 'error';
        isNavigating = false;
        return;
      }
    }

    currentRoute = null;
    currentParams = {};
    currentComponent = null;
    routerState = 'not-found';
    isNavigating = false;
  }

  function extractParams(pathname: string, routeData: any): Record<string, string> {
    const params: Record<string, string> = {};
    const pathSegments = pathname.split('/').filter(Boolean);
    const routeSegments = routeData.path ? routeData.path.split('/').filter(Boolean) : [];

    if (routeSegments.includes('*')) {
      const catchAllIndex = routeSegments.indexOf('*');
      const paramName = routeData.params && routeData.params[0] || 'catchAll';
      params[paramName] = pathSegments.slice(catchAllIndex).join('/');
      return params;
    }

    for (let i = 0; i < routeSegments.length; i++) {
      const routeSegment = routeSegments[i];
      const pathSegment = pathSegments[i];

      if (routeSegment && routeSegment.startsWith(':')) {
        const paramName = routeSegment.replace(/^:|[?*]$/g, '');
        if (pathSegment !== undefined) {
          params[paramName] = decodeURIComponent(pathSegment);
        }
      }
    }

    return params;
  }

  async function loadComponent(component: any): Promise<void> {
    if (!component) {
      currentComponent = null;
      return;
    }

    try {
      if (typeof component === 'function') {
        const module = await component();
        currentComponent = module.default || module;
        return;
      }
      currentComponent = component;
    } catch (error) {
      console.error('Failed to load component:', error);
      routerError = error as Error;
      routerState = 'error';
      throw error;
    }
  }

  function handlePopState(): void {
    isNavigating = true;
    updateLocation();
  }

  function handleLinkClick(event: MouseEvent): void {
    const target = event.target as HTMLElement;
    const link = target.closest('a[href]') as HTMLAnchorElement;

    if (!link || link.target === '_blank' || link.download) return;
    if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;

    const href = link.getAttribute('href');
    if (!href || href.startsWith('http') || href.startsWith('//') || href.startsWith('mailto:') || href.startsWith('tel:')) return;

    event.preventDefault();
    navigate(href);
  }

  $effect(() => {
    router = buildRouter(routes);
  });

  onMount(async () => {
    await loadRoutes();

    if (isBrowser) {
      updateLocation();
      window.addEventListener('popstate', handlePopState);
      document.addEventListener('click', handleLinkClick);
      return;
    }

    routerState = 'ready';
  });

  onDestroy(() => {
    if (!isBrowser) return;

    window.removeEventListener('popstate', handlePopState);
    document.removeEventListener('click', handleLinkClick);
  });

  const locationContext = getContext('location');

  $effect(() => {
    if (locationContext && !isBrowser && routes.length > 0) {
      currentLocation = {
        pathname: locationContext.pathname,
        search: locationContext.search || '',
        hash: locationContext.hash || ''
      };

      const currentRouter = buildRouter(routes);
      const match = findRoute(currentRouter, "GET", currentLocation.pathname);
      if (match && match.data) {
        currentRoute = match.data;
        currentParams = extractParams(currentLocation.pathname, match.data);

        if (match.data.component && typeof match.data.component !== 'function') {
          currentComponent = match.data.component;
        }
      }
      routerState = 'ready';
    }
  });
</script>

{#if routerState === 'loading'}
  <div class="flex items-center justify-center min-h-screen">
    {#if loading}
      {@render loading()}
    {:else}
      <div class="text-center">
        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"></div>
        <p class="text-gray-600">Loading...</p>
      </div>
    {/if}
  </div>
{/if}

{#if routerState === 'ready' && currentComponent}
  {@const Component = currentComponent}
  <Component
    params={currentParams}
  />
{/if}

{#if routerState === 'not-found'}
  <div class="flex items-center justify-center min-h-screen">
    {#if fallback}
      {@const FallbackComponent = fallback}
      <FallbackComponent />
    {:else}
      <div class="text-center">
        <h1 class="text-4xl font-bold text-gray-800 mb-4">404 - Page Not Found</h1>
        <p class="text-gray-600">The page you are looking for could not be found.</p>
      </div>
    {/if}
  </div>
{/if}

{#if routerState === 'error'}
  <div class="flex items-center justify-center min-h-screen">
    {#if error}
      {@render error({ routerError })}
    {:else}
      <div class="text-center p-8">
        <h1 class="text-2xl font-bold text-red-600 mb-4">Router Error</h1>
        <p class="text-gray-600 mb-4">Failed to initialize router: {routerError?.message || 'Unknown error'}</p>
        <button
          class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
          onclick={() => window.location.reload()}
        >
          Reload Page
        </button>
      </div>
    {/if}
  </div>
{/if}
